## 网络安全的核心问题

- 保密性：防止信息被截获、窃听（加密）
- 一致性：防止信息被篡改（摘要）、身份被冒充（签名）
- 可用性：防止服务受攻击而不可用


### 保密

##### 对称加密

双方用同一套算法和同一个密钥，进行通信加解密。可双向使用（一对一）

代表算法：DES、AES

好的密码体制应该满足：算法可公开，保密性仅取决于密钥的保密性和暴力破解密钥的难度。也即不可能通过算法破解密钥或密文

通过增加密钥长度或多重加密可以无限提高暴力破解难度，主要的问题还是在于密钥的保密性，特别是分发传输过程中的保密性


##### 非对称加密

公钥加密，是多对一的通信加密，发送方通过接收方的公钥加密信息，接收方通过自己的私钥解密信息

代表算法：RSA

公钥和私钥可以成对的生成，但无法通过公钥推算出私钥（计算上不可能）

公钥和算法都是可公开的，公钥只能加密，不能解密，只有私钥能解密

满足交换律：对信息 X 先用私钥作解密运算再用公钥作加密运算，跟先用公钥加密再用私钥解密，结果是一样的。这种特点，使得公钥密码体制，既可以用于加密，又可以用于签名

加密和签名的主要区别是：签名，任何人都可以拿公钥“解密”，签名仅仅用于证明信息是谁发出的，完全不保密


### 鉴别

鉴别，用于解决一致性问题，主要包含两方面内容：对信息来源的识别，对信息完整性的校验


##### 信息来源的识别：签名

发送方对信息用私钥做“解密”运算（签名），接收方用公钥做“加密”运算（核实、验证）


##### 信息完整性的校验：摘要（digest）

摘要，是基于散列实现的

散列是一种算法公开的、多对一的单向有损压缩技术

- 压缩：最终输出的是长度固定的值
- 单向有损：不可能通过输出值还原输入值
- 多对一：输入值无限，输出值有限，必然是多对一。散列函数需要做到“在计算上不可能找到两个输出值相同的输入值”，换言之，任何一个输入不管发生任何变化，都“一定”会得到完全不一样的输出值

因此，散列可以验证信息的完整性，没有被劫持、篡改、偷换

验证的基本思路：发送方将计算出的散列加密后添加到信息之后一并传输，接受方取出信息算出散列，并与解密后的散列作对比

> [摘要算法：Cryptographic Hash Algorithms](https://en.wikipedia.org/wiki/Cryptographic_hash_function#Cryptographic_hash_algorithms)


##### 报文鉴别

每个报文都通过上述散列算法校验


##### 实体鉴别

与报文鉴别不同，实体鉴别在单次会话中仅首次校验


### 密钥分发

##### 非对称加密如何分发公钥

公钥分发的关键问题不是加密（因为不需要），也不是篡改（改了后就没用了），而是身份鉴别，因此理论上可以用签名技术解决

但是，接收方已有公钥时，可通过对普通信息的签名认证确认发送来源，如果没有公钥，接收方就没办法验证公钥来源的可靠性

换句话说，接收方必须已经拥有对方的公钥，签名技术才是有效的

因此必须有一个公认的、专门的、第三方公钥分发中心（Trusted Third Party），即 CA（认证中心，Certification Authority）。CA 的公钥是完全公开已知的，因此可以通过签名确认信息的确来自 CA。通过 CA 来发送各方的公钥，接收方可以确定没有问题。每个接受方都可以从 CA 获取发送方的公钥

CA 将实体的身份信息及其公钥绑定，就形成了【证书】（A certificate is a public key with a label identifying the owner）


### 证书

证书类似于身份证
    - Domain validated（DV），仅包含域名信息（可以包含多个，甚至是 wildcard：`*.xxx.com`）
    - Extended validation（EV），包含经营实体的信息
    - Organization validated (OV) ，类似 EV，但浏览器不展示经营者信息，因而更便宜


> 参考：《计算机网络》（第7版）谢希仁
