### 算法存在的必要性

- 条件一：计算机本质上只会少数几种基本操作
- 条件二：任何高维运算都由有限数量的基本操作组成
- 条件三：尽管计算机的运算速度很快，但终究是有限的

> 推论一：对于高维运算，如果需要的基本操作数量越多，那么耗时就越长

> 推论二：要实现程序性能最大化，就必须保证高维运算所需的基本操作数最小化

结论：算法的必要性源于计算机基本操作和运算速度的有限性，算法的作用或目的就是确保基本操作数最小化


### 算法是什么

- 广义的讲，算法就是解决问题的思路
- 狭义的讲，算法就是一个个具名的、公式化的实现逻辑
- 从抽象层次看，算法在高维度表现为方法论，高维方法论是对低维算法的抽象描述，低维算法是对高维方法论的具体实现
- 五大通用方法论：分治、动态规划、贪心、回溯、分支限界


### 数据结构存在的必要性

- 条件一：计算机的存储结构本质上非常单一
- 条件二：任何运算都必须依赖存储结构

> 推论一：存储结构的局限性，会导致某些运算不得不动用大量基本操作

> 推论二：要优化程序性能，就必须突破存储结构的局限

结论：数据结构的必要性源于存储结构的局限性。数据结构的作用或目的是突破原始存储结构的局限性，最小化运算所需的基本操作数


### 数据结构是什么

- 数据结构是存储结构的高维抽象
- 数据结构具备某些良好的性质，可以突破原始存储结构的局限性


### 算法与数据结构

- 条件一：算法和数据结构都可以降低运算所需的基本操作数
- 条件二：算法的最终体现是数据运算
- 条件三：数据运算依赖于数据结构

> 推论一：运算所需基本操作数的最小化，有赖于算法与数据结构的共同实现

> 推论二：算法依赖于数据结构，数据结构是算法的前提和约束


### 抽象数据类型

- 数据类型是数据与方法的集合，是通过数据结构和算法实现的。数据类型可以用一组 API 进行描述。数据类型的具体实现由内部封装并对外暴露接口，故称为抽象数据类型
- 抽象数据类型通常可以用多种数据结构实现
- 常见数据结构：
  + 数组 Array
  + 链表 Linkedlist
  + 堆 Heap
  + 树 Tree
  + 图 Graph
- 常见抽象数据类型：
  + 字符串 String
  + 数组 Array
  + 背包 Bag
  + 队列 Queque
  + 栈 Stack
  + 列表 List
  + 优先队列 Priority Queque
  + 符号表 Symbol Table | 字典 Dictionary
  + 散列表 Hash Table

> [数据结构示意图](https://www.interviewcake.com/data-structures-reference)

> [data-structures-in-javascript](https://medium.com/siliconwat/data-structures-in-javascript-1b9aed0ea17c)


### 算法的衡量标准

- 时间维度：算法耗时与数据量的关系
  + 执行每条语句的时间
  + 执行每条语句的频率
- 空间维度：算法与内存的关系

- 在时间维度中，每条语句或者说每个基本操作的时间可视为常数，因此衡量的关键在于明确基本操作的频率。而程序运行的时间很大程度上是由某一部分语句（通常是循环）决定的，因此需要明确究竟是哪一些基本操作的频率对时间的影响是决定性的。

- 计算 t 与 N 的准确的函数关系对于算法研究的必要性并不大，因此通常采取近似方法。近似方法降低了算法分析的复杂度，但是忽略简化内容可能导致近似分析与实际结果产生不一致，这些简化内容包括：
  + 大常数。当输入值很小时，某些被省略的非关键操作可能就变成了关键操作
  + 指令时间。指令时间并非全都相等且固定不变

- 某些算法与输入有关，输入不同，算法性能可能出现跃阶式的变化，对于这种情况，常常需要额外的处理，比如随机化、均摊等
- 某些算法与概率有关，即便是完全相同的输入，每次消耗的时间也可能不一样，因此通常采用区间描述，给出最好情形与最坏情形的上限与下限
- 从时间维度描述算法性能的方法通常有两种：
  + 增长级数
    - 常数级：1
    - 对数级：logN
    - 线性级：N
    - 线性对数级：NlogN
    - 平方级：N^2
    - 立方级：N^3
    - 指数级：C^N
  + 成本模型
    - 某算法花费了 f(N) 次基本操作或某算法需要 f(N) ~ g(N) 次基本操作
